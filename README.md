# Abstract
> package number: 1

Gradient in 3D space will be computed as follows:
- for a given input, the function produces an output
- for any input/output to be processed, the function must have some identity
- for identity to be used to identify the function, there must be some representational coordinate
- a positional coordinate by which representation may occur will have a scalar field associated
- for scalar field to be placed, the scaling must induce distinguishable changes to the field
- for any change to be differentiated from any other change, there must be a vector whose defining characteristics must also be distinct
- for a vector to distinctly point towards some direction, the field must have a vector field
- for vectors to be directed with some identifiable origin at its base, its tip must follow a unique direction for scaling in that effect
- for direction to be specified, the field must have another associated vector whose relative differences in angle defines the two field variables
- for a field to have a unique and distinct unique variable property, there must be an associated identity whose links connect all the changes and nodes define relative changes
- for relative changes to occur without changing the identity, the relative identity vector must have inverse whose sum reduces to trivial quantities
- for a non trivial quantity to cause trivial attributes in another non trivial substrate, there must be non trivial attributes whose association could yield another non trivial attribute
- for two non trivial attributes to be supported by a common substrate, there must be non trivial resources whose use could yield construction on another non trivial resources
- for such circular non trivial graphs to exist, something must support its instantiation trivially

**those constructors whose product yields non trivial objects from trivial resources are provided by the laws of physics**

> for any positional vector, there is an associated field whose set of possible attributes contain another set of possible positional vectors.

> a transform of the field attributes from a state, the vector resulting from the event will encode all the information about the system (provided the origin remain constant!)

> for two different positional coordinates, the angle that the head makes from the normal vector to the planar field, encodes the directional vector effected by that angle whose greatest and quickest increase yields the maximum level of elevation

> from the maximumally elevated level, the point that marks the interface between the substrate's inner and outer parameters, projection of that information onto the horizontal plane encodes the gradient information

> from the point on the horizontal plane where star lands, the distance from origin to that point along planar direction encodes the relative distance between to two scalar transforms

> for a delta step in the direction away from that maximum scaled norm will minimize the norm of the identity by scaling inversely towards to origin from the farthest point in the horizon

> for finding the optimal trajectory in NOT planar path graphs but in the transforms that effect the whole state whose parameters may only take scalar targets

> for an optimal tracing of the stars while minimizing other reducible paths, the quickest way to converge onto the state where the stars are the linear target point where the density of the space is such that provides sharpest view of the gradient variables

**instead of encoding x: input, y: prediction, z: loss, we should encode the data such that a regular cycle with set of points taking on z values encodes phase shifts, and during the cycle for every z variable, the set of (x, y) values + prompt value -> completion value and z + 1**

if we minimize the whole (x, y, z) for i at t, the (X, Y, Z, T) + (PROMPT, COMPLETION, PRODUCT, INTERVAL) ~ (I * U) + (U * T)




# Logic
> package number: 6

The logic of actions taken through constructive and destructive processes, is not written in the language of computer architectures or design principles.

1. What physical process do the action represent and how could we approximate a constructor that performs a set of tasks in place of sponteneous actions?

> It is very hard to pinpoint what is being activated and where is that event taking place. Also it is equally complex to wonder about the type of thing that is instantiating the events, or what concept class from a finite bounded domain and then what finite catagory that domain is nearest to .. the main intention being the approximation of the complex task to finite indicies that could be contrasted using other things near those values and hence trying to locate approximate problem instances.
>
> But this could not work or at least never produce relavent knowledge that is what being required here and moreover we should take much stricter set of definitions that do produce concrete knowledge but does no probabilistic approximations or kinds of that nature.

- We can exactly describe what we apparantly capable of describing and make no direct assertions to the value being hidden
- We can however move on to disjoint spaces were the "disjointness" is both reactively-apparantly distinguishable, then it is a valid task of describing two such discrete set of attributes with a new description that could follow only the usual requirements
- The only conserved quantities that such a free-form solution should match would have to be some physical attributes that not necessarily are sharply declared but rather kept in static form in their relative instantiation whether through physically adjustable interfaces or indirect reference/pointer form by at least one of the parameters present in active substrates.

## Conserved Quantity

Attaching a flash drive through usb interface on a macOS system would make transferring possible from device to drive and reverse.

When the OS allows for locating the applications that makes the drive discoverable and all communication is done through some set of applications like such, there is no unique existance of that detachable object in the graph that describe all transitions and associated functions. Except when there are many such discoverable addresses and we have to exclusively consider the possible set of items with respect to the actions we would perform on that connection specifically excluding all other connections where we cannot exclusively cause the tranfer of our subjected quantities across and over.

This is a fictional probing event that no one would naturally be found in practicing in that manner, but the concern is still a very legitimate one and even one of fundamental ones for the kind of discussions we are in the middle of here. Suppose the drive is perfectly usable but offen the os would loose the bits that contained the exact physical address of the drive and everytime we make transfer across the two medium, we have to explicitly make a file containing the physicsl addresses remain available on the root path of the drive.

With that added complexity it is now a parameter of the kind that causes conservation of some quantity whenever there is a differentiable notion of change in the overlapping set of spaces and descriptions between the two media, consituting a new unique medium where that conserved quantitites are at direct association with all the possible descriptions that could be constructed from the instantiated relationships.

- the device information and drive information is one of the attributes from a set of intrinsic attributes that define the whole space of parametric functions
- one of those functions would provide the relative measure variable for the free-form encoding groups that was mentioned at the top
- whenever one point of data changes at one of the substrate, there is a simultaneous response that would have to reach one substrate from the other providing knowledge that certain change would be possible and could occur but has not yet occur, and respectively the conjugate part will send message saying one of the possible changes that was not made is just now made avaialble and the availability is not acknowledged by the other component at that instance.
- finally the medium will provide broadcast to each of the possible observers stating that all agreed upon protocols are respected by all participating entities and one such instantiation of protocol was present in one of the levels, finally the other levels where no pending change was queued should expect one change due to one of the mutable attributes being mutated.

2. Consider a file system where tasks like reading, writing, seeking, streaming, updating, extendind, locating, searching etc. made available through two kinds of root operators. Let the operators be agents following the genetic definition of an agent object, and two root instances are symmetric reflection of a single unit identity.
   For a set of addressable file objects, assume that the two agents create a energy landscape with each of them adjusting their pan values opposing the rotation of the other.
   So for k file instances, the infinite set of degrees between the central area contained within the jointly made open-space and let the space be partioned into k subspaces from - phase to + phase.
   What function should this spectrum be defined with?



# Latest

**keeping zero in place**
..

**stretching and squishing**
..

**actions and groups**
..

**composition of actions**
..

**collection of actions and single action**
..

**symmetry**
..

**bilaterall symmetry**
..

**lateral symmetry**
..

**leaving them all looking the same**
..

**what are all the groups**
..

**the simple group**
..

**what other actions**
..


## Structure

**objects**

- skull / hypersurface
- displacement / derivative operator
- thickness / delta factor
- eye basis / Z basis
- Z basis / g basis
- ground / G operator
- elevation / g basis
- displaced / reference basis
- closeform / reference basis
- perp operator / 2-spheres
- 3-speres / perp basis
- orthogonal dual / central eye-ar
- eye-ar perp / ear conjugates
- ear conjugates / eye conjugates
- hadamard dual / densely connected
- densely connected / mono-iso stereomer
- azimuth / reference
- angular / vectorial
- fixed position / root solver
- root / antipodal
- star invarient / reference invarience
- projector-projection / static-dynamic
- ground-lift / phantom group
- temporal / medial
- medium / medial
- medial / information
- medial / substrate
- 2-state / 2-level
- ortho / mean
- symmetry-group / laterus-group
- mu / alpha
- alpha / mirror
- mirror / supererior
- mid-side / left-right
- commutator / master
- master / qubit
- bit / commutator

**Tasks**
- [0] spherical embedding of fixed point
- [1] coordinate search from spherical attributes
- [2] amplitude translation of panner state
- [3] gain structure of space-time operator
- [4] loss structure of temporal observer
- [5] find basis vectors of agent-operator symmetry
- [6] derivation of reference vector from embedded point
- [7] azimuth calculation using point symmetry in sphere
- [8] star mapping from data on hypersphere
- [9] projection of surface tensor in spherical object
- [10] perpendicular projection from radial basis to planar basis
- [11] dynamical change computation of fixed point inside a sphere with finite mean projection
- [12] interpolation of edges of fixed node with closed set
- [13] solver methods for node-antinode transformers

**Methods**
- [0] `embed(object, cartesian_config)`, `fixed_point(object, spherical_config)`
- [1] `search_coordinate(object, state_dict)`, `share_attribute(object, specification=None)`
- [2] `convert_gain(object, waveform, target_mixer)`, `get_properties(object, channel=0)`
- [3] `gain_structure(object, last_state, gradient=True)`, `operating_matrix(object, scalar_loss, vector_loss)`
- [4] `loss_structure(object, gradient=False)`, `trainer_matrix(object, scalar_loss, vector_loss)`
- [5] `sample_parameter(object, node, antinode)`, `symmetric_linear(object, sample_token)`, `compose_channel(object, constructor, agent, operator)`, `nonlinear_merge(constructor, spacetime_tensor)`, `merge_constructor(object, state_dict)`
- [6] `compute_displacement(object, tensor)`, `trace_reference(object, delta_embedding, energy_level)`
- [7] `calculate_azimuth(object, channel, structure)`
- [8] `encode_byte(object, amplitude, token)`, `map_integer(object, tensor, star)`, `project_from_volume(object, ball, set, config)`, `decode_perimeter(object, volume, config)`
- [9] `spherical_line(object, extended_state)`, `unit_motion(object, line, projector)`
- [10] `perp(object, r, A)`, `project(object, panner, plane)`
- [11] `step(Q, T, S)`, `measure(object, q, x)`, `feedforward(object, input, hidden)`
- [12] `prepare_substrate(object, measure)`, `render(object, mixer, structure)`, `interpolate(object, mid, side)`
- [13] `encode_stereo(object, left, right)`, `decode_stereo(object, node, antinode)`, `load_coil(Transformer, mid, side)`, `wind_forward(object, phantom, node)`, `wind_backard(object, solution, antinode)`
