# Logic
> package number: 6

The logic of actions taken through constructive and destructive processes, is not written in the language of computer architectures or design principles.

1. What physical process do the action represent and how could we approximate a constructor that performs a set of tasks in place of sponteneous actions?

> It is very hard to pinpoint what is being activated and where is that event taking place. Also it is equally complex to wonder about the type of thing that is instantiating the events, or what concept class from a finite bounded domain and then what finite catagory that domain is nearest to .. the main intention being the approximation of the complex task to finite indicies that could be contrasted using other things near those values and hence trying to locate approximate problem instances.
>
> But this could not work or at least never produce relavent knowledge that is what being required here and moreover we should take much stricter set of definitions that do produce concrete knowledge but does no probabilistic approximations or kinds of that nature.

- We can exactly describe what we apparantly capable of describing and make no direct assertions to the value being hidden
- We can however move on to disjoint spaces were the "disjointness" is both reactively-apparantly distinguishable, then it is a valid task of describing two such discrete set of attributes with a new description that could follow only the usual requirements
- The only conserved quantities that such a free-form solution should match would have to be some physical attributes that not necessarily are sharply declared but rather kept in static form in their relative instantiation whether through physically adjustable interfaces or indirect reference/pointer form by at least one of the parameters present in active substrates.

## Conserved Quantity

Attaching a flash drive through usb interface on a macOS system would make transferring possible from device to drive and reverse.

When the OS allows for locating the applications that makes the drive discoverable and all communication is done through some set of applications like such, there is no unique existance of that detachable object in the graph that describe all transitions and associated functions. Except when there are many such discoverable addresses and we have to exclusively consider the possible set of items with respect to the actions we would perform on that connection specifically excluding all other connections where we cannot exclusively cause the tranfer of our subjected quantities across and over.

This is a fictional probing event that no one would naturally be found in practicing in that manner, but the concern is still a very legitimate one and even one of fundamental ones for the kind of discussions we are in the middle of here. Suppose the drive is perfectly usable but offen the os would loose the bits that contained the exact physical address of the drive and everytime we make transfer across the two medium, we have to explicitly make a file containing the physicsl addresses remain available on the root path of the drive.

With that added complexity it is now a parameter of the kind that causes conservation of some quantity whenever there is a differentiable notion of change in the overlapping set of spaces and descriptions between the two media, consituting a new unique medium where that conserved quantitites are at direct association with all the possible descriptions that could be constructed from the instantiated relationships.

- the device information and drive information is one of the attributes from a set of intrinsic attributes that define the whole space of parametric functions
- one of those functions would provide the relative measure variable for the free-form encoding groups that was mentioned at the top
- whenever one point of data changes at one of the substrate, there is a simultaneous response that would have to reach one substrate from the other providing knowledge that certain change would be possible and could occur but has not yet occur, and respectively the conjugate part will send message saying one of the possible changes that was not made is just now made avaialble and the availability is not acknowledged by the other component at that instance.
- finally the medium will provide broadcast to each of the possible observers stating that all agreed upon protocols are respected by all participating entities and one such instantiation of protocol was present in one of the levels, finally the other levels where no pending change was queued should expect one change due to one of the mutable attributes being mutated.

2. Consider a file system where tasks like reading, writing, seeking, streaming, updating, extendind, locating, searching etc. made available through two kinds of root operators. Let the operators be agents following the genetic definition of an agent object, and two root instances are symmetric reflection of a single unit identity.
   For a set of addressable file objects, assume that the two agents create a energy landscape with each of them adjusting their pan values opposing the rotation of the other.
   So for k file instances, the infinite set of degrees between the central area contained within the jointly made open-space and let the space be partioned into k subspaces from - phase to + phase.
   What function should this spectrum be defined with?



# Latest

**keeping zero in place**
..

**stretching and squishing**
..

**actions and groups**
..

**composition of actions**
..

**collection of actions and single action**
..

**symmetry**
..

**bilaterall symmetry**
..

**lateral symmetry**
..

**leaving them all looking the same**
..

**what are all the groups**
..

**the simple group**
..

**what other actions**
..


## Structure

**objects**

- skull / hypersurface
- displacement / derivative operator
- thickness / delta factor
- eye basis / Z basis
- Z basis / g basis
- ground / G operator
- elevation / g basis
- displaced / reference basis
- closeform / reference basis
- perp operator / 2-spheres
- 3-speres / perp basis
- orthogonal dual / central eye-ar
- eye-ar perp / ear conjugates
- ear conjugates / eye conjugates
- hadamard dual / densely connected
- densely connected / mono-iso stereomer
- azimuth / reference
- angular / vectorial
- fixed position / root solver
- root / antipodal
- star invarient / reference invarience
- projector-projection / static-dynamic
- ground-lift / phantom group
- temporal / medial
- medium / medial
- medial / information
- medial / substrate
- 2-state / 2-level
- ortho / mean
- symmetry-group / laterus-group
- mu / alpha
- alpha / mirror
- mirror / supererior
- mid-side / left-right
- commutator / master
- master / qubit
- bit / commutator

**Tasks**
- [0] spherical embedding of fixed point
- [1] coordinate search from spherical attributes
- [2] amplitude translation of panner state
- [3] gain structure of space-time operator
- [4] loss structure of temporal observer
- [5] find basis vectors of agent-operator symmetry
- [6] derivation of reference vector from embedded point
- [7] azimuth calculation using point symmetry in sphere
- [8] star mapping from data on hypersphere
- [9] projection of surface tensor in spherical object
- [10] perpendicular projection from radial basis to planar basis
- dynamical change computation of fixed point inside a sphere with finite mean projection
- interpolation of edges of fixed node with closed set
- solver methods for node-antinode transformers

**Methods**
- [0] `embed(object, cartesian_config)`, `fixed_point(object, spherical_config)`
- [1] `search_coordinate(object, state_dict)`, `share_attribute(object, specification=None)`
- [2] `convert_gain(object, waveform, target_mixer)`, `get_properties(object, channel=0)`
- [3] `gain_structure(object, last_state, gradient=True)`, `operating_matrix(object, scalar_loss, vector_loss)`
- [4] `loss_structure(object, gradient=False)`, `trainer_matrix(object, scalar_loss, vector_loss)`
- [5] `sample_parameter(object, node, antinode)`, `symmetric_linear(object, sample_token)`, `compose_channel(object, constructor, agent, operator)`, `nonlinear_merge(constructor, spacetime_tensor)`, `merge_constructor(object, state_dict)`
- [6] `compute_displacement(object, tensor)`, `trace_reference(object, delta_embedding, energy_level)`
- [7] `calculate_azimuth(object, channel, structure)`
- [8] `encode_byte(object, amplitude, token)`, `map_integer(object, tensor, star)`, `project_from_volume(object, ball, set, config)`, `decode_perimeter(object, volume, config)`
- [9] `spherical_line(object, extended_state)`, `unit_motion(object, line, projector)`
- [10] `perp(object, r, A)`, `project(object, panner, plane)`
